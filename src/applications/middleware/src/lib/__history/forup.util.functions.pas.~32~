unit forup.util.functions;

interface
uses System.Rtti, System.TypInfo, System.JSON, System.JSON.Builders, System.JSON.Converters,
System.Classes, System.StrUtils, System.Math, System.MaskUtils, System.Masks, System.DateUtils,
Generics.Collections, forup.util.constants, System.SysUtils;

type
  {Singleton Class - Multiple porpuse}
  TFunctions = class
    strict private
      class var FInstance : TFunctions;
      class var FClassName : string;
    private
      constructor CreatePrivate;
    public
      class procedure RegisterClass;
      class function GetFunctions : TFunctions;

      {List manipulation}
      class function getLine(aValues : TArray<string>; aSeparetor : char = ','; aFormat : string = EMPTYSTRING) : string; overload;
      class function getLine(aValues : TStrings; aSeparetor : char = ','; aFormat : string = EMPTYSTRING) : string; overload;
      {End of List manipulation}

      {Database trasnform functions}
      class function db_string(aValue : string; aReturnNull : Boolean = false) : string;
      class function db_integer(aValue : string; aReturnNull : Boolean = false) : string; overload;
      class function db_integer(aValue : integer; aReturnNull : Boolean = false) : string; overload;
      class function db_double(aValue : string; aReturnNull : Boolean = false) : string; overload;
      class function db_double(aValue : Extended; aReturnNull : Boolean = false) : string; overload;
      class function db_date(aValue : string; aReturnNull : Boolean = false) : string; overload;
      class function db_date(aValue : TDate; aReturnNull : Boolean = false) : string; overload;
      class function db_time(aValue : string; aReturnNull : Boolean = false) : string; overload;
      class function db_time(aValue : TTime; aReturnNull : Boolean = false) : string; overload;
      class function db_datetime(aValue : string; aReturnNull : Boolean = false) : string; overload;
      class function db_datetime(aValue : TDateTime; aReturnNull : Boolean = false) : string; overload;
      class function db_boolean(aValue : string; aReturnNull : Boolean = false) : string; overload;
      class function db_boolean(aValue : integer; aReturnNull : Boolean = false) : string; overload;
      class function db_boolean(aValue : boolean; aReturnNull : Boolean = false) : string; overload;
      {End of Database trasnform}

  end;

implementation

{ TFunctions }

constructor TFunctions.CreatePrivate;
begin
  {Destinated to apply the ambiantation for the Class}
end;

class function TFunctions.db_integer(aValue: string;
  aReturnNull: Boolean): string;
var
  intVal : Integer;
begin
  if aValue.IsEmpty then
    begin
      if aReturnNull then
        begin
          Result := 'NULL';
        end
      else Result := 'E';
    end
  else
    begin
      if aValue.ToUpper.Equals('NULL') then
        Result := aValue
      else
        begin
          if TryStrToInt(aValue, intVal) then
            Result := aValue
          else
            Result := 'E';
        end;
    end;
end;

class function TFunctions.db_boolean(aValue, aReturnNull: Boolean): string;
begin
  if aReturnNull then
    begin
      Result := 'NULL';
    end
  else
    begin
      if aValue then
        Result := 'true'
      else
        Result := 'false';
    end;
end;

class function TFunctions.db_boolean(aValue: integer;
  aReturnNull: Boolean): string;
begin

end;

class function TFunctions.db_boolean(aValue: string;
  aReturnNull: Boolean): string;
begin

end;

class function TFunctions.db_date(aValue: TDate; aReturnNull: Boolean): string;
begin

end;

class function TFunctions.db_date(aValue: string; aReturnNull: Boolean): string;
begin

end;

class function TFunctions.db_datetime(aValue: TDateTime;
  aReturnNull: Boolean): string;
begin

end;

class function TFunctions.db_datetime(aValue: string;
  aReturnNull: Boolean): string;
begin

end;

class function TFunctions.db_double(aValue: string;
  aReturnNull: Boolean): string;
begin

end;

class function TFunctions.db_double(aValue: Extended;
  aReturnNull: Boolean): string;
begin

end;

class function TFunctions.db_integer(aValue: integer;
  aReturnNull: Boolean): string;
begin
  try
    Result := aValue.ToString;
  except
    Result := 'E';
  end;
end;

class function TFunctions.db_string(aValue: string;
  aReturnNull: Boolean): string;
begin
  if aValue.IsEmpty then
    begin
      if aReturnNull then
        begin
          Result := 'NULL';
        end
      else Result := QuotedStr('');
    end
  else
    begin
      if aValue.ToUpper.Equals('NULL') then
        Result := aValue
      else
        Result := QuotedStr(aValue);
    end;
end;

class function TFunctions.db_time(aValue: string; aReturnNull: Boolean): string;
begin

end;

class function TFunctions.db_time(aValue: TTime; aReturnNull: Boolean): string;
begin

end;

class function TFunctions.GetFunctions: TFunctions;
begin
  if not Assigned(Self.FInstance) then
    FInstance := TFunctions.CreatePrivate;

  Result := FInstance;
end;

class function TFunctions.getLine(aValues: TStrings; aSeparetor: char;
  aFormat: string): string;
var
  it : Integer;
begin
  Result := EMPTYSTRING;
  for it := 0 to aValues.Count-1 do
    begin
      if it < (aValues.Count-1) then
        Result := concat(Result, aValues[it], aSeparetor)
      else
        Result := concat(Result, aValues[it])
    end;

  if not (aFormat.isEmpty) then
    begin
      Result := Format(aFormat, [Result]);
    end;
end;

class function TFunctions.getLine(aValues: TArray<string>; aSeparetor: char;
  aFormat: string): string;
var
  it : Integer;
begin
  Result := EMPTYSTRING;
  for it := 0 to Length(aValues)-1 do
    begin
      if it < (Length(aValues)-1) then
        Result := concat(Result, aValues[it], aSeparetor)
      else
        Result := concat(Result, aValues[it])
    end;

  if not (aFormat.isEmpty) then
    begin
      Result := Format(aFormat, [Result]);
    end;
end;

class procedure TFunctions.RegisterClass;
begin
  Self.FClassName := Self.ClassName;
end;

end.
